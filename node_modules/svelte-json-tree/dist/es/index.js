var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { SvelteComponent, init, safe_not_equal, append_styles, element, attr, toggle_class, insert, append, listen, detach, empty, noop, component_subscribe, subscribe, set_store_value, create_slot, update_slot_base, get_all_dirty_from_scope, get_slot_changes, transition_in, transition_out, create_component, mount_component, destroy_component, stop_propagation, space, group_outros, check_outros, destroy_each, text, set_data, null_to_empty, get_spread_update, get_spread_object, assign } from "svelte/internal";
import { getContext, setContext, onMount } from "svelte";
import { writable, readable } from "svelte/store";
const STATE = {};
function useState(newState, opts) {
  const currentState = getContext(STATE);
  const _newState = typeof newState === "function" ? newState(currentState) : newState;
  const nextState = __spreadValues(__spreadValues({}, currentState), _newState);
  if (opts == null ? void 0 : opts.expandable)
    nextState.isParentExpanded = nextState.expanded;
  setContext(STATE, nextState);
  return currentState;
}
function add_css$8(target) {
  append_styles(target, "svelte-1qd6nto", ".container.svelte-1qd6nto{display:inline-block;transform:translate(calc(0px - var(--li-identation)), -50%);position:absolute;top:50%;padding-right:100%}.arrow.svelte-1qd6nto{transform-origin:25% 50%;position:relative;line-height:1.1em;font-size:0.75em;margin-left:0;transition:150ms;color:var(--arrow-color);user-select:none;font-family:'Courier New', Courier, monospace;display:block}.expanded.svelte-1qd6nto{transform:rotateZ(90deg) translateX(-3px)}");
}
function create_if_block$8(ctx) {
  let span1;
  let span0;
  let mounted;
  let dispose;
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      span0.textContent = `${"\u25B6"}`;
      attr(span0, "class", "arrow svelte-1qd6nto");
      toggle_class(span0, "expanded", ctx[2]);
      attr(span1, "class", "container svelte-1qd6nto");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, span0);
      if (!mounted) {
        dispose = listen(span1, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        toggle_class(span0, "expanded", ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span1);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$i(ctx) {
  let if_block_anchor;
  let if_block = ctx[1] && create_if_block$8(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $expandable;
  let $expanded, $$unsubscribe_expanded = noop, $$subscribe_expanded = () => ($$unsubscribe_expanded(), $$unsubscribe_expanded = subscribe(expanded, ($$value) => $$invalidate(2, $expanded = $$value)), expanded);
  $$self.$$.on_destroy.push(() => $$unsubscribe_expanded());
  const { expanded: _expanded, expandable } = useState();
  component_subscribe($$self, expandable, (value) => $$invalidate(1, $expandable = value));
  let { expanded = _expanded } = $$props;
  $$subscribe_expanded();
  const click_handler = (event) => {
    event.stopPropagation();
    set_store_value(expanded, $expanded = !$expanded, $expanded);
  };
  $$self.$$set = ($$props2) => {
    if ("expanded" in $$props2)
      $$subscribe_expanded($$invalidate(0, expanded = $$props2.expanded));
  };
  return [expanded, $expandable, $expanded, expandable, click_handler];
}
class JSONArrow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$i, safe_not_equal, { expanded: 0 }, add_css$8);
  }
}
function create_fragment$h(ctx) {
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  useState({ displayMode: "summary" });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class Summary extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$h, safe_not_equal, {});
  }
}
function create_fragment$g(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { expanded } = $$props;
  let { key } = $$props;
  const expandable = writable(false);
  useState(({ keyPath, level }) => {
    if (key !== "[[Entries]]") {
      keyPath = [...keyPath, key];
      level = level + 1;
    }
    return { keyPath, level, expanded, expandable };
  });
  $$self.$$set = ($$props2) => {
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [expanded, key, $$scope, slots];
}
class Expandable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$g, safe_not_equal, { expanded: 0, key: 1 });
  }
}
function add_css$7(target) {
  append_styles(target, "svelte-19drypg", ".root.svelte-19drypg{display:inline-block;position:relative}.indent.svelte-19drypg{padding-left:var(--li-identation)}.label.svelte-19drypg{position:relative}");
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[21] = i;
  return child_ctx;
}
const get_item_value_slot_changes = (dirty) => ({ key: dirty & 1 });
const get_item_value_slot_context = (ctx) => ({
  key: ctx[19],
  index: ctx[21]
});
const get_item_key_slot_changes = (dirty) => ({ key: dirty & 1 });
const get_item_key_slot_context = (ctx) => ({
  key: ctx[19],
  index: ctx[21]
});
const get_preview_slot_changes = (dirty) => ({});
const get_preview_slot_context = (ctx) => ({});
const get_summary_slot_changes = (dirty) => ({});
const get_summary_slot_context = (ctx) => ({});
function create_else_block$6(ctx) {
  let span;
  let t0;
  let summary;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[6] && create_if_block_3$2(ctx);
  summary = new Summary({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  let if_block1 = ctx[4] && create_if_block_1$2(ctx);
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(summary.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(span, "class", "root svelte-19drypg");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t0);
      mount_component(summary, span, null);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[6])
        if_block0.p(ctx2, dirty);
      const summary_changes = {};
      if (dirty & 8192) {
        summary_changes.$$scope = { dirty, ctx: ctx2 };
      }
      summary.$set(summary_changes);
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(summary.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(summary.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block0)
        if_block0.d();
      destroy_component(summary);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$7(ctx) {
  let current;
  const summary_slot_template = ctx[11].summary;
  const summary_slot = create_slot(summary_slot_template, ctx, ctx[13], get_summary_slot_context);
  return {
    c() {
      if (summary_slot)
        summary_slot.c();
    },
    m(target, anchor) {
      if (summary_slot) {
        summary_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & 8192)) {
          update_slot_base(summary_slot, summary_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(summary_slot_template, ctx2[13], dirty, get_summary_slot_changes), get_summary_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(summary_slot, local);
      current = true;
    },
    o(local) {
      transition_out(summary_slot, local);
      current = false;
    },
    d(detaching) {
      if (summary_slot)
        summary_slot.d(detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let jsonarrow;
  let current;
  jsonarrow = new JSONArrow({ props: { expanded: ctx[7] } });
  return {
    c() {
      create_component(jsonarrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonarrow, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(jsonarrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonarrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonarrow, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let current;
  const preview_slot_template = ctx[11].preview;
  const preview_slot = create_slot(preview_slot_template, ctx, ctx[13], get_preview_slot_context);
  return {
    c() {
      if (preview_slot)
        preview_slot.c();
    },
    m(target, anchor) {
      if (preview_slot) {
        preview_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (preview_slot) {
        if (preview_slot.p && (!current || dirty & 8192)) {
          update_slot_base(preview_slot, preview_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(preview_slot_template, ctx2[13], dirty, get_preview_slot_changes), get_preview_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(preview_slot, local);
      current = true;
    },
    o(local) {
      transition_out(preview_slot, local);
      current = false;
    },
    d(detaching) {
      if (preview_slot)
        preview_slot.d(detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(ul, "click", stop_propagation(ctx[9]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8223) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$2(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = ":";
      attr(span, "class", "operator");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot$1(ctx) {
  let span;
  let jsonarrow;
  let show_if = !ctx[1] || ctx[1](ctx[19]);
  let t;
  let current;
  let mounted;
  let dispose;
  jsonarrow = new JSONArrow({});
  const item_key_slot_template = ctx[11].item_key;
  const item_key_slot = create_slot(item_key_slot_template, ctx, ctx[13], get_item_key_slot_context);
  let if_block = show_if && create_if_block_2$2();
  function click_handler() {
    return ctx[12](ctx[21]);
  }
  const item_value_slot_template = ctx[11].item_value;
  const item_value_slot = create_slot(item_value_slot_template, ctx, ctx[13], get_item_value_slot_context);
  return {
    c() {
      span = element("span");
      create_component(jsonarrow.$$.fragment);
      if (item_key_slot)
        item_key_slot.c();
      if (if_block)
        if_block.c();
      t = space();
      if (item_value_slot)
        item_value_slot.c();
      attr(span, "class", "label svelte-19drypg");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(jsonarrow, span, null);
      if (item_key_slot) {
        item_key_slot.m(span, null);
      }
      if (if_block)
        if_block.m(span, null);
      append(span, t);
      if (item_value_slot) {
        item_value_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_key_slot) {
        if (item_key_slot.p && (!current || dirty & 8193)) {
          update_slot_base(item_key_slot, item_key_slot_template, ctx, ctx[13], !current ? get_all_dirty_from_scope(ctx[13]) : get_slot_changes(item_key_slot_template, ctx[13], dirty, get_item_key_slot_changes), get_item_key_slot_context);
        }
      }
      if (dirty & 3)
        show_if = !ctx[1] || ctx[1](ctx[19]);
      if (show_if) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2$2();
          if_block.c();
          if_block.m(span, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (item_value_slot) {
        if (item_value_slot.p && (!current || dirty & 8193)) {
          update_slot_base(item_value_slot, item_value_slot_template, ctx, ctx[13], !current ? get_all_dirty_from_scope(ctx[13]) : get_slot_changes(item_value_slot_template, ctx[13], dirty, get_item_value_slot_changes), get_item_value_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonarrow.$$.fragment, local);
      transition_in(item_key_slot, local);
      transition_in(item_value_slot, local);
      current = true;
    },
    o(local) {
      transition_out(jsonarrow.$$.fragment, local);
      transition_out(item_key_slot, local);
      transition_out(item_value_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(jsonarrow);
      if (item_key_slot)
        item_key_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (item_value_slot)
        item_value_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$2(ctx) {
  let li;
  let expandable_1;
  let t;
  let current;
  let mounted;
  let dispose;
  expandable_1 = new Expandable({
    props: {
      key: ctx[2](ctx[19]),
      expanded: ctx[3][ctx[21]],
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li = element("li");
      create_component(expandable_1.$$.fragment);
      t = space();
      attr(li, "class", "svelte-19drypg");
      toggle_class(li, "indent", ctx[4]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(expandable_1, li, null);
      append(li, t);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", stop_propagation(click_handler_1));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const expandable_1_changes = {};
      if (dirty & 5)
        expandable_1_changes.key = ctx2[2](ctx2[19]);
      if (dirty & 8)
        expandable_1_changes.expanded = ctx2[3][ctx2[21]];
      if (dirty & 8203) {
        expandable_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandable_1.$set(expandable_1_changes);
      if (dirty & 16) {
        toggle_class(li, "indent", ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(expandable_1);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$f(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5] === "summary")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
const click_handler_1 = () => {
};
function instance$f($$self, $$props, $$invalidate) {
  let child_expanded;
  let $expanded;
  let $expandable;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { keys } = $$props;
  let { shouldShowColon = void 0 } = $$props;
  let { expandKey = (key) => key } = $$props;
  let { defaultExpanded = false } = $$props;
  const { isParentExpanded, displayMode, root, expanded, expandable, keyPath, level, shouldExpandNode } = useState({ root: false }, { expandable: true });
  component_subscribe($$self, expanded, (value) => $$invalidate(4, $expanded = value));
  component_subscribe($$self, expandable, (value) => $$invalidate(14, $expandable = value));
  set_store_value(expandable, $expandable = true, $expandable);
  if (displayMode !== "summary") {
    if (!defaultExpanded) {
      const controlled = shouldExpandNode({ keyPath, level });
      if (controlled !== void 0) {
        defaultExpanded = controlled;
      }
    }
    onMount(() => {
      return isParentExpanded.subscribe((value) => {
        if (!value)
          expanded.set(false);
        else
          expanded.set(defaultExpanded);
      });
    });
  }
  function toggleExpand() {
    set_store_value(expanded, $expanded = !$expanded, $expanded);
  }
  const click_handler = (index) => child_expanded[index].update((value) => !value);
  $$self.$$set = ($$props2) => {
    if ("keys" in $$props2)
      $$invalidate(0, keys = $$props2.keys);
    if ("shouldShowColon" in $$props2)
      $$invalidate(1, shouldShowColon = $$props2.shouldShowColon);
    if ("expandKey" in $$props2)
      $$invalidate(2, expandKey = $$props2.expandKey);
    if ("defaultExpanded" in $$props2)
      $$invalidate(10, defaultExpanded = $$props2.defaultExpanded);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(3, child_expanded = keys.map(() => writable(false)));
    }
  };
  return [
    keys,
    shouldShowColon,
    expandKey,
    child_expanded,
    $expanded,
    displayMode,
    root,
    expanded,
    expandable,
    toggleExpand,
    defaultExpanded,
    slots,
    click_handler,
    $$scope
  ];
}
class JSONNested extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$f, safe_not_equal, {
      keys: 0,
      shouldShowColon: 1,
      expandKey: 2,
      defaultExpanded: 10
    }, add_css$7);
  }
}
function add_css$6(target) {
  append_styles(target, "svelte-150ffaa", ".comma.svelte-150ffaa{margin-left:-0.5em;margin-right:0.5em}");
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
const get_item_slot_changes = (dirty) => ({ item: dirty & 1 });
const get_item_slot_context = (ctx) => ({
  item: ctx[7],
  index: ctx[9]
});
function create_if_block_3$1(ctx) {
  let span;
  let t;
  let if_block = ctx[2] && create_if_block_4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      span = element("span");
      t = text(ctx[3]);
      attr(span, "class", "operator");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(span.parentNode, span);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[2]);
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = ",";
      attr(span, "class", "comma operator svelte-150ffaa");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$1(ctx) {
  let t;
  let if_block_anchor;
  let current;
  const item_slot_template = ctx[6].item;
  const item_slot = create_slot(item_slot_template, ctx, ctx[5], get_item_slot_context);
  let if_block = ctx[9] < ctx[0].length - 1 && create_if_block_2$1();
  return {
    c() {
      if (item_slot)
        item_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (item_slot) {
        item_slot.m(target, anchor);
      }
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (item_slot) {
        if (item_slot.p && (!current || dirty & 33)) {
          update_slot_base(item_slot, item_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(item_slot_template, ctx2[5], dirty, get_item_slot_changes), get_item_slot_context);
        }
      }
      if (ctx2[9] < ctx2[0].length - 1) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2$1();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_slot)
        item_slot.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$1(ctx) {
  let span0;
  let t1;
  let span1;
  return {
    c() {
      span0 = element("span");
      span0.textContent = ",";
      t1 = space();
      span1 = element("span");
      span1.textContent = "\u2026";
      attr(span0, "class", "comma operator svelte-150ffaa");
      attr(span1, "class", "operator");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span1);
    }
  };
}
function create_if_block$6(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[4]);
      attr(span, "class", "operator");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$e(ctx) {
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[3] && create_if_block_3$1(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = ctx[1] && create_if_block_1$1();
  let if_block2 = ctx[4] && create_if_block$6(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$1(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 33) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_1$1();
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$6(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { list } = $$props;
  let { hasMore } = $$props;
  let { label = void 0 } = $$props;
  let { prefix = void 0 } = $$props;
  let { postfix = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("list" in $$props2)
      $$invalidate(0, list = $$props2.list);
    if ("hasMore" in $$props2)
      $$invalidate(1, hasMore = $$props2.hasMore);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("prefix" in $$props2)
      $$invalidate(3, prefix = $$props2.prefix);
    if ("postfix" in $$props2)
      $$invalidate(4, postfix = $$props2.postfix);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [list, hasMore, label, prefix, postfix, $$scope, slots];
}
class PreviewList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$e, safe_not_equal, {
      list: 0,
      hasMore: 1,
      label: 2,
      prefix: 3,
      postfix: 4
    }, add_css$6);
  }
}
function create_summary_slot$8(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${"{\u2026}"}`;
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_slot$5(ctx) {
  let span0;
  let t0_value = ctx[4] + "";
  let t0;
  let span1;
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[4]] }
  });
  return {
    c() {
      span0 = element("span");
      t0 = text(t0_value);
      span1 = element("span");
      span1.textContent = `${": "}`;
      create_component(jsonnode.$$.fragment);
      attr(span0, "class", "property");
      attr(span1, "class", "operator");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      append(span0, t0);
      insert(target, span1, anchor);
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 16) && t0_value !== (t0_value = ctx2[4] + ""))
        set_data(t0, t0_value);
      const jsonnode_changes = {};
      if (dirty & 17)
        jsonnode_changes.value = ctx2[0][ctx2[4]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span0);
      if (detaching)
        detach(span1);
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_preview_slot$8(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: ctx[2],
      hasMore: ctx[2].length < ctx[1].length,
      prefix: "{",
      postfix: "}",
      $$slots: {
        item: [
          create_item_slot$5,
          ({ item }) => ({ 4: item }),
          ({ item }) => item ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(previewlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const previewlist_changes = {};
      if (dirty & 4)
        previewlist_changes.list = ctx2[2];
      if (dirty & 6)
        previewlist_changes.hasMore = ctx2[2].length < ctx2[1].length;
      if (dirty & 49) {
        previewlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      previewlist.$set(previewlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
}
function create_item_key_slot$8(ctx) {
  let span;
  let t_value = ctx[3] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot$8(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[3]] }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 9)
        jsonnode_changes.value = ctx2[0][ctx2[3]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[1],
      $$slots: {
        item_value: [
          create_item_value_slot$8,
          ({ key }) => ({ 3: key }),
          ({ key }) => key ? 8 : 0
        ],
        item_key: [
          create_item_key_slot$8,
          ({ key }) => ({ 3: key }),
          ({ key }) => key ? 8 : 0
        ],
        preview: [create_preview_slot$8],
        summary: [create_summary_slot$8]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 2)
        jsonnested_changes.keys = ctx2[1];
      if (dirty & 47) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let keys;
  let previewKeys;
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, keys = Object.getOwnPropertyNames(value));
    }
    if ($$self.$$.dirty & 2) {
      $$invalidate(2, previewKeys = keys.slice(0, 5));
    }
  };
  return [value, keys, previewKeys];
}
class JSONObjectNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$d, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$7(ctx) {
  let span;
  let t0;
  let t1_value = ctx[0].length + "";
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text("Array(");
      t1 = text(t1_value);
      t2 = text(")");
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_slot$4(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({ props: { value: ctx[4] } });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 16)
        jsonnode_changes.value = ctx2[4];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_preview_slot$7(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: ctx[1],
      hasMore: ctx[1].length < ctx[0].length,
      label: "(" + ctx[0].length + ") ",
      prefix: "[",
      postfix: "]",
      $$slots: {
        item: [
          create_item_slot$4,
          ({ item }) => ({ 4: item }),
          ({ item }) => item ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(previewlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const previewlist_changes = {};
      if (dirty & 2)
        previewlist_changes.list = ctx2[1];
      if (dirty & 3)
        previewlist_changes.hasMore = ctx2[1].length < ctx2[0].length;
      if (dirty & 1)
        previewlist_changes.label = "(" + ctx2[0].length + ") ";
      if (dirty & 48) {
        previewlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      previewlist.$set(previewlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
}
function create_item_key_slot$7(ctx) {
  let span;
  let t_value = String(ctx[3]) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = String(ctx2[3]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot$7(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[3]] }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 9)
        jsonnode_changes.value = ctx2[0][ctx2[3]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_fragment$c(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[2],
      $$slots: {
        item_value: [
          create_item_value_slot$7,
          ({ key }) => ({ 3: key }),
          ({ key }) => key ? 8 : 0
        ],
        item_key: [
          create_item_key_slot$7,
          ({ key }) => ({ 3: key }),
          ({ key }) => key ? 8 : 0
        ],
        preview: [create_preview_slot$7],
        summary: [create_summary_slot$7]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 4)
        jsonnested_changes.keys = ctx2[2];
      if (dirty & 43) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let keys;
  let preview;
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(2, keys = Object.getOwnPropertyNames(value));
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, preview = value.slice(0, 5));
    }
  };
  return [value, preview, keys];
}
class JSONArrayNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$c, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$6(ctx) {
  let span;
  let t0;
  let t1;
  let t2_value = ctx[3].length + "";
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(ctx[1]);
      t1 = text("(");
      t2 = text(t2_value);
      t3 = text(")");
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 8 && t2_value !== (t2_value = ctx2[3].length + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_slot$3(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({ props: { value: ctx[8] } });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 256)
        jsonnode_changes.value = ctx2[8];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_preview_slot$6(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: ctx[4],
      hasMore: ctx[4].length < ctx[2].length,
      label: `${ctx[1]}(${ctx[3].length}) `,
      prefix: "{",
      postfix: "}",
      $$slots: {
        item: [
          create_item_slot$3,
          ({ item }) => ({ 8: item }),
          ({ item }) => item ? 256 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(previewlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const previewlist_changes = {};
      if (dirty & 16)
        previewlist_changes.list = ctx2[4];
      if (dirty & 20)
        previewlist_changes.hasMore = ctx2[4].length < ctx2[2].length;
      if (dirty & 10)
        previewlist_changes.label = `${ctx2[1]}(${ctx2[3].length}) `;
      if (dirty & 768) {
        previewlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      previewlist.$set(previewlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
}
function create_item_key_slot_1$1(ctx) {
  let span;
  let t_value = ctx[6] + "";
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = ctx[6] === ENTRIES$1 ? "internal" : "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6] + ""))
        set_data(t, t_value);
      if (dirty & 64 && span_class_value !== (span_class_value = ctx2[6] === ENTRIES$1 ? "internal" : "property")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block$5(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[6]] }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 65)
        jsonnode_changes.value = ctx2[0][ctx2[6]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_if_block$5(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[3],
      defaultExpanded: true,
      $$slots: {
        item_value: [
          create_item_value_slot_1$1,
          ({ key: index }) => ({ 7: index }),
          ({ key: index }) => index ? 128 : 0
        ],
        item_key: [
          create_item_key_slot$6,
          ({ key: index }) => ({ 7: index }),
          ({ key: index }) => index ? 128 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnested_changes = {};
      if (dirty & 8)
        jsonnested_changes.keys = ctx2[3];
      if (dirty & 644) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
function create_item_key_slot$6(ctx) {
  let span;
  let t_value = ctx[7] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = ctx2[7] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot_1$1(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[2][ctx[7]]
    }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 132)
        jsonnode_changes.value = ctx2[2][ctx2[7]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_item_value_slot$6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$5, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] === ENTRIES$1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$b(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: [ENTRIES$1, "size"],
      shouldShowColon: ctx[5],
      $$slots: {
        item_value: [
          create_item_value_slot$6,
          ({ key }) => ({ 6: key }),
          ({ key }) => key ? 64 : 0
        ],
        item_key: [
          create_item_key_slot_1$1,
          ({ key }) => ({ 6: key }),
          ({ key }) => key ? 64 : 0
        ],
        preview: [create_preview_slot$6],
        summary: [create_summary_slot$6]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 607) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
const ENTRIES$1 = "[[Entries]]";
function instance$b($$self, $$props, $$invalidate) {
  let previewItems;
  let { value } = $$props;
  let { nodeType } = $$props;
  let indexes = [];
  let items = [];
  const func = (key) => key !== ENTRIES$1;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("nodeType" in $$props2)
      $$invalidate(1, nodeType = $$props2.nodeType);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        let _indexes = [];
        let _items = [];
        let i = 0;
        for (const entry of value) {
          _indexes.push(i++);
          _items.push(entry);
        }
        $$invalidate(3, indexes = _indexes);
        $$invalidate(2, items = _items);
      }
    }
    if ($$self.$$.dirty & 4) {
      $$invalidate(4, previewItems = items.slice(0, 5));
    }
  };
  return [value, nodeType, items, indexes, previewItems, func];
}
class JSONIterableArrayNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$b, safe_not_equal, { value: 0, nodeType: 1 });
  }
}
function create_summary_slot$5(ctx) {
  let span;
  let t0;
  let t1_value = ctx[2].length + "";
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text("Map(");
      t1 = text(t1_value);
      t2 = text(")");
      attr(span, "color", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t1_value !== (t1_value = ctx2[2].length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_slot$2(ctx) {
  let jsonnode0;
  let span;
  let jsonnode1;
  let current;
  jsonnode0 = new JSONNode({ props: { value: ctx[10] } });
  jsonnode1 = new JSONNode({
    props: {
      value: ctx[0].get(ctx[10])
    }
  });
  return {
    c() {
      create_component(jsonnode0.$$.fragment);
      span = element("span");
      span.textContent = `${" => "}`;
      create_component(jsonnode1.$$.fragment);
      attr(span, "class", "operator");
    },
    m(target, anchor) {
      mount_component(jsonnode0, target, anchor);
      insert(target, span, anchor);
      mount_component(jsonnode1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode0_changes = {};
      if (dirty & 1024)
        jsonnode0_changes.value = ctx2[10];
      jsonnode0.$set(jsonnode0_changes);
      const jsonnode1_changes = {};
      if (dirty & 1025)
        jsonnode1_changes.value = ctx2[0].get(ctx2[10]);
      jsonnode1.$set(jsonnode1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode0.$$.fragment, local);
      transition_in(jsonnode1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode0.$$.fragment, local);
      transition_out(jsonnode1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode0, detaching);
      if (detaching)
        detach(span);
      destroy_component(jsonnode1, detaching);
    }
  };
}
function create_preview_slot_1(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: ctx[4],
      hasMore: ctx[4].length < ctx[0].size,
      label: `Map(${ctx[2].length}) `,
      prefix: `{`,
      postfix: "}",
      $$slots: {
        item: [
          create_item_slot$2,
          ({ item }) => ({ 10: item }),
          ({ item }) => item ? 1024 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(previewlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const previewlist_changes = {};
      if (dirty & 16)
        previewlist_changes.list = ctx2[4];
      if (dirty & 17)
        previewlist_changes.hasMore = ctx2[4].length < ctx2[0].size;
      if (dirty & 4)
        previewlist_changes.label = `Map(${ctx2[2].length}) `;
      if (dirty & 3073) {
        previewlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      previewlist.$set(previewlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
}
function create_item_key_slot_2(ctx) {
  let span;
  let t_value = ctx[7] + "";
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = ctx[7] === ENTRIES ? "internal" : "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = ctx2[7] + ""))
        set_data(t, t_value);
      if (dirty & 128 && span_class_value !== (span_class_value = ctx2[7] === ENTRIES ? "internal" : "property")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block$4(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[7]] }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 129)
        jsonnode_changes.value = ctx2[0][ctx2[7]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_if_block$4(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[1],
      expandKey: ctx[5],
      defaultExpanded: true,
      $$slots: {
        item_value: [
          create_item_value_slot_1,
          ({ key: index }) => ({ 8: index }),
          ({ key: index }) => index ? 256 : 0
        ],
        item_key: [
          create_item_key_slot_1,
          ({ key: index }) => ({ 8: index }),
          ({ key: index }) => index ? 256 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnested_changes = {};
      if (dirty & 2)
        jsonnested_changes.keys = ctx2[1];
      if (dirty & 4)
        jsonnested_changes.expandKey = ctx2[5];
      if (dirty & 2316) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
function create_item_key_slot_1(ctx) {
  let span;
  let t_value = ctx[8] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 256 && t_value !== (t_value = ctx2[8] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_preview_slot$5(ctx) {
  let span0;
  let jsonnode0;
  let span1;
  let jsonnode1;
  let span2;
  let current;
  jsonnode0 = new JSONNode({
    props: { value: ctx[2][ctx[8]] }
  });
  jsonnode1 = new JSONNode({
    props: {
      value: ctx[3][ctx[8]]
    }
  });
  return {
    c() {
      span0 = element("span");
      span0.textContent = `${"{ "}`;
      create_component(jsonnode0.$$.fragment);
      span1 = element("span");
      span1.textContent = `${" => "}`;
      create_component(jsonnode1.$$.fragment);
      span2 = element("span");
      span2.textContent = `${" }"}`;
      attr(span0, "class", "operator");
      attr(span1, "class", "operator");
      attr(span2, "class", "operator");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      mount_component(jsonnode0, target, anchor);
      insert(target, span1, anchor);
      mount_component(jsonnode1, target, anchor);
      insert(target, span2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode0_changes = {};
      if (dirty & 260)
        jsonnode0_changes.value = ctx2[2][ctx2[8]];
      jsonnode0.$set(jsonnode0_changes);
      const jsonnode1_changes = {};
      if (dirty & 264)
        jsonnode1_changes.value = ctx2[3][ctx2[8]];
      jsonnode1.$set(jsonnode1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode0.$$.fragment, local);
      transition_in(jsonnode1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode0.$$.fragment, local);
      transition_out(jsonnode1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span0);
      destroy_component(jsonnode0, detaching);
      if (detaching)
        detach(span1);
      destroy_component(jsonnode1, detaching);
      if (detaching)
        detach(span2);
    }
  };
}
function create_item_key_slot$5(ctx) {
  let span;
  let t_value = ctx[9] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t_value !== (t_value = ctx2[9] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot_2(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[9] === "key" ? ctx[2][ctx[8]] : ctx[3][ctx[8]]
    }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 780)
        jsonnode_changes.value = ctx2[9] === "key" ? ctx2[2][ctx2[8]] : ctx2[3][ctx2[8]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_item_value_slot_1(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ["key", "value"],
      $$slots: {
        item_value: [
          create_item_value_slot_2,
          ({ key: name }) => ({ 9: name }),
          ({ key: name }) => name ? 512 : 0
        ],
        item_key: [
          create_item_key_slot$5,
          ({ key: name }) => ({ 9: name }),
          ({ key: name }) => name ? 512 : 0
        ],
        preview: [create_preview_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnested_changes = {};
      if (dirty & 2828) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
function create_item_value_slot$5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$4, create_else_block$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7] === ENTRIES)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$a(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: [ENTRIES, "size"],
      shouldShowColon: ctx[6],
      $$slots: {
        item_value: [
          create_item_value_slot$5,
          ({ key }) => ({ 7: key }),
          ({ key }) => key ? 128 : 0
        ],
        item_key: [
          create_item_key_slot_2,
          ({ key }) => ({ 7: key }),
          ({ key }) => key ? 128 : 0
        ],
        preview: [create_preview_slot_1],
        summary: [create_summary_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 2207) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
const ENTRIES = "[[Entries]]";
function instance$a($$self, $$props, $$invalidate) {
  let previewKeys;
  let { value } = $$props;
  useState();
  let indexes = [];
  let keys = [];
  let values = [];
  const func = (index) => keys[index];
  const func_1 = (key) => key !== ENTRIES;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        let _indexes = [];
        let _keys = [];
        let _values = [];
        let i = 0;
        for (const entry of value) {
          _indexes.push(i++);
          _keys.push(entry[0]);
          _values.push(entry[1]);
        }
        $$invalidate(1, indexes = _indexes);
        $$invalidate(2, keys = _keys);
        $$invalidate(3, values = _values);
      }
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(4, previewKeys = Array.from(value.keys()).slice(0, 5));
    }
  };
  return [value, indexes, keys, values, previewKeys, func, func_1];
}
class JSONIterableMapNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$a, safe_not_equal, { value: 0 });
  }
}
function add_css$5(target) {
  append_styles(target, "svelte-l95iub", ".Date.svelte-l95iub{color:var(--date-color)}.BigInt.svelte-l95iub{color:var(--number-color)}.Number.svelte-l95iub{color:var(--number-color)}.Boolean.svelte-l95iub{color:var(--boolean-color)}.Null.svelte-l95iub{color:var(--null-color)}.Undefined.svelte-l95iub{color:var(--undefined-color)}.Symbol.svelte-l95iub{color:var(--symbol-color)}");
}
function create_fragment$9(ctx) {
  let span;
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "class", span_class_value = null_to_empty(ctx[1]) + " svelte-l95iub");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 2 && span_class_value !== (span_class_value = null_to_empty(ctx2[1]) + " svelte-l95iub")) {
        attr(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { value, nodeType } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("nodeType" in $$props2)
      $$invalidate(1, nodeType = $$props2.nodeType);
  };
  return [value, nodeType];
}
class JSONValueNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$9, safe_not_equal, { value: 0, nodeType: 1 }, add_css$5);
  }
}
function add_css$4(target) {
  append_styles(target, "svelte-1u08yw6", ".indent.svelte-1u08yw6{padding-left:var(--li-identation)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[9] = i;
  const constants_0 = child_ctx[9] < child_ctx[0].length - 1;
  child_ctx[7] = constants_0;
  return child_ctx;
}
function create_else_block$3(ctx) {
  let span;
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][0] + "\u2026" }
  });
  return {
    c() {
      span = element("span");
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(jsonnode, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 1)
        jsonnode_changes.value = ctx2[0][0] + "\u2026";
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(jsonnode);
    }
  };
}
function create_if_block$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block(ctx) {
  let span1;
  let jsonnode;
  let span0;
  let t_value = ctx[7] ? " +" : "";
  let t;
  let br;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[6] + (ctx[7] ? "\\n" : "")
    }
  });
  return {
    c() {
      span1 = element("span");
      create_component(jsonnode.$$.fragment);
      span0 = element("span");
      t = text(t_value);
      br = element("br");
      attr(span0, "class", "operator");
      attr(span1, "class", "svelte-1u08yw6");
      toggle_class(span1, "indent", ctx[9] > 0);
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      mount_component(jsonnode, span1, null);
      append(span1, span0);
      append(span0, t);
      insert(target, br, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 1)
        jsonnode_changes.value = ctx2[6] + (ctx2[7] ? "\\n" : "");
      jsonnode.$set(jsonnode_changes);
      if ((!current || dirty & 1) && t_value !== (t_value = ctx2[7] ? " +" : ""))
        set_data(t, t_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span1);
      destroy_component(jsonnode);
      if (detaching)
        detach(br);
    }
  };
}
function create_fragment$8(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$3, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $expandable;
  let $expanded;
  let { stack } = $$props;
  const { expanded, expandable } = useState();
  component_subscribe($$self, expanded, (value) => $$invalidate(1, $expanded = value));
  component_subscribe($$self, expandable, (value) => $$invalidate(5, $expandable = value));
  set_store_value(expandable, $expandable = true, $expandable);
  const click_handler = () => set_store_value(expanded, $expanded = !$expanded, $expanded);
  $$self.$$set = ($$props2) => {
    if ("stack" in $$props2)
      $$invalidate(0, stack = $$props2.stack);
  };
  return [stack, $expanded, expanded, expandable, click_handler];
}
class ErrorStack extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, { stack: 0 }, add_css$4);
  }
}
function create_summary_slot$4(ctx) {
  let span;
  let t0;
  let t1_value = String(ctx[0].message) + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Error: ");
      t1 = text(t1_value);
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = String(ctx2[0].message) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_preview_slot$4(ctx) {
  let span;
  let t0;
  let t1_value = String(ctx[0].message) + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Error: ");
      t1 = text(t1_value);
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = String(ctx2[0].message) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_key_slot$4(ctx) {
  let span;
  let t_value = ctx[2] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[2] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block$2(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[2]] }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 5)
        jsonnode_changes.value = ctx2[0][ctx2[2]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_if_block$2(ctx) {
  let errorstack;
  let current;
  errorstack = new ErrorStack({ props: { stack: ctx[1] } });
  return {
    c() {
      create_component(errorstack.$$.fragment);
    },
    m(target, anchor) {
      mount_component(errorstack, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const errorstack_changes = {};
      if (dirty & 2)
        errorstack_changes.stack = ctx2[1];
      errorstack.$set(errorstack_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(errorstack.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(errorstack.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(errorstack, detaching);
    }
  };
}
function create_item_value_slot$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$2, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] === "stack")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$7(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ["message", "stack"],
      $$slots: {
        item_value: [
          create_item_value_slot$4,
          ({ key }) => ({ 2: key }),
          ({ key }) => key ? 4 : 0
        ],
        item_key: [
          create_item_key_slot$4,
          ({ key }) => ({ 2: key }),
          ({ key }) => key ? 4 : 0
        ],
        preview: [create_preview_slot$4],
        summary: [create_summary_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 15) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let stack;
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, stack = value.stack.split("\n"));
    }
  };
  return [value, stack];
}
class ErrorNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, { value: 0 });
  }
}
function objType(obj) {
  const type = Object.prototype.toString.call(obj).slice(8, -1);
  if (type === "Object") {
    if (typeof obj[Symbol.iterator] === "function") {
      return "Iterable";
    }
    return obj.constructor.name;
  }
  return type;
}
function add_css$3(target) {
  append_styles(target, "svelte-1fvwa9c", "span.svelte-1fvwa9c{color:var(--string-color);word-break:break-all;word-wrap:break-word}");
}
function create_else_block$1(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text('"');
      t1 = text(ctx[0]);
      t2 = text('"');
      attr(span, "class", "svelte-1fvwa9c");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t1, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$1(ctx) {
  let span;
  let t0;
  let t1_value = ctx[0].slice(0, 30) + (ctx[0].length > 30 ? "\u2026" : "");
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text('"');
      t1 = text(t1_value);
      t2 = text('"');
      attr(span, "class", "svelte-1fvwa9c");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].slice(0, 30) + (ctx2[0].length > 30 ? "\u2026" : "")))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$6(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === "summary")
      return create_if_block$1;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let serialised;
  let { value } = $$props;
  const map = { "\n": "\\n", "	": "\\t", "\r": "\\r" };
  const { displayMode } = useState();
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(0, serialised = value.replace(/[\n\t\r]/g, (_) => map[_]));
    }
  };
  return [serialised, displayMode, value];
}
class JSONStringNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, { value: 2 }, add_css$3);
  }
}
function add_css$2(target) {
  append_styles(target, "svelte-1eamqdt", ".i.svelte-1eamqdt{font-style:italic}.fn.svelte-1eamqdt,.i.svelte-1eamqdt{color:var(--function-color)}");
}
function create_summary_slot$3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "\u0192";
      attr(span, "class", "i svelte-1eamqdt");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3(ctx) {
  let span;
  let t_value = getPreview1(ctx[2]) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "fn i svelte-1eamqdt");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = getPreview1(ctx2[2]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2(ctx) {
  let span;
  let t_value = getPreview2(ctx[2]) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "i svelte-1eamqdt");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = getPreview2(ctx2[2]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_preview_slot$3(ctx) {
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block0 = !ctx[2].isArrow && create_if_block_3(ctx);
  let if_block1 = !ctx[2].isClass && create_if_block_2(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, if_block0_anchor, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!ctx2[2].isArrow) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[2].isClass) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(if_block0_anchor);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_item_key_slot$3(ctx) {
  let span;
  let t_value = ctx[7] + "";
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = ctx[7] === FUNCTION || ctx[7] === PROTO ? "internal" : "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = ctx2[7] + ""))
        set_data(t, t_value);
      if (dirty & 128 && span_class_value !== (span_class_value = ctx2[7] === FUNCTION || ctx2[7] === PROTO ? "internal" : "property")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[3](ctx[7])
    }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 128)
        jsonnode_changes.value = ctx2[3](ctx2[7]);
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let jsonobjectnode;
  let current;
  jsonobjectnode = new JSONObjectNode({
    props: {
      value: ctx[3](ctx[7])
    }
  });
  return {
    c() {
      create_component(jsonobjectnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonobjectnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonobjectnode_changes = {};
      if (dirty & 128)
        jsonobjectnode_changes.value = ctx2[3](ctx2[7]);
      jsonobjectnode.$set(jsonobjectnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonobjectnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonobjectnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonobjectnode, detaching);
    }
  };
}
function create_if_block(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "class", "i svelte-1eamqdt");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot$3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7] === FUNCTION)
      return 0;
    if (ctx2[7] === "prototype")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$5(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[1],
      $$slots: {
        item_value: [
          create_item_value_slot$3,
          ({ key }) => ({ 7: key }),
          ({ key }) => key ? 128 : 0
        ],
        item_key: [
          create_item_key_slot$3,
          ({ key }) => ({ 7: key }),
          ({ key }) => key ? 128 : 0
        ],
        preview: [create_preview_slot$3],
        summary: [create_summary_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 2)
        jsonnested_changes.keys = ctx2[1];
      if (dirty & 389) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
const FUNCTION = "[[Function]]";
const PROTO = "[[Prototype]]";
function getPreview1({ isGenerator, isAsync, isClass }) {
  if (isClass)
    return `class ${isClass}`;
  return (isAsync ? "async " : "") + "\u0192" + (isGenerator ? "*" : "");
}
function getPreview2({ isAsync, isArrow, fnName, args }) {
  return (isArrow && isAsync ? "async" : "") + " " + (fnName != null ? fnName : "") + args + (isArrow ? " => \u2026" : "");
}
function toString(value) {
  try {
    return value.toString();
  } catch {
    switch (value.constructor.name) {
      case "AsyncFunction":
        return "async function () {}";
      case "AsyncGeneratorFunction":
        return "async function * () {}";
      case "GeneratorFunction:":
        return "function * () {}";
      default:
        return "function () {}";
    }
  }
}
function instance$5($$self, $$props, $$invalidate) {
  let str;
  let ctx;
  let keys;
  let { value } = $$props;
  function parseFunction(str2) {
    const match = str2.match(/^(?:(async)\s+)?(?:function)?(\*)?\s*([^(]+)?(\([^)]*\))\s*(=>)?/);
    const isAsync = match == null ? void 0 : match[1];
    const isGenerator = match == null ? void 0 : match[2];
    const fnName = match == null ? void 0 : match[3];
    const args = match == null ? void 0 : match[4];
    const isArrow = match == null ? void 0 : match[5];
    const classMatch = str2.match(/^class\s+([^\s]+)/);
    const isClass = classMatch == null ? void 0 : classMatch[1];
    return {
      args,
      isAsync,
      isGenerator,
      fnName,
      isArrow,
      isClass
    };
  }
  function getValue(key) {
    if (key === PROTO)
      return value.__proto__;
    return value[key];
  }
  function filterKeys(key) {
    if (key === FUNCTION)
      return true;
    return getValue(key);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(4, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(0, str = toString(value));
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(2, ctx = parseFunction(str));
    }
  };
  $$invalidate(1, keys = ["length", "name", "prototype", FUNCTION, PROTO].filter(filterKeys));
  return [str, keys, ctx, getValue, value];
}
class JSONFunctionNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, { value: 4 }, add_css$2);
  }
}
function create_summary_slot$2(ctx) {
  let span;
  let t0_value = ctx[3] ? "writable(" : "readable(";
  let t0;
  let jsonnode;
  let t1_value = ")";
  let t1;
  let current;
  jsonnode = new JSONNode({ props: { value: ctx[2] } });
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      create_component(jsonnode.$$.fragment);
      t1 = text(t1_value);
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      mount_component(jsonnode, span, null);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 8) && t0_value !== (t0_value = ctx2[3] ? "writable(" : "readable("))
        set_data(t0, t0_value);
      const jsonnode_changes = {};
      if (dirty & 4)
        jsonnode_changes.value = ctx2[2];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(jsonnode);
    }
  };
}
function create_item_slot$1(ctx) {
  let span0;
  let t0_value = ctx[9] + "";
  let t0;
  let span1;
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[9]] }
  });
  return {
    c() {
      span0 = element("span");
      t0 = text(t0_value);
      span1 = element("span");
      span1.textContent = `${": "}`;
      create_component(jsonnode.$$.fragment);
      attr(span0, "class", "property");
      attr(span1, "class", "operator");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      append(span0, t0);
      insert(target, span1, anchor);
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 512) && t0_value !== (t0_value = ctx2[9] + ""))
        set_data(t0, t0_value);
      const jsonnode_changes = {};
      if (dirty & 513)
        jsonnode_changes.value = ctx2[0][ctx2[9]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span0);
      if (detaching)
        detach(span1);
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_preview_slot$2(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: ctx[4],
      hasMore: ctx[4].length < ctx[1].length,
      prefix: "{",
      postfix: "}",
      $$slots: {
        item: [
          create_item_slot$1,
          ({ item }) => ({ 9: item }),
          ({ item }) => item ? 512 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(previewlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const previewlist_changes = {};
      if (dirty & 16)
        previewlist_changes.list = ctx2[4];
      if (dirty & 18)
        previewlist_changes.hasMore = ctx2[4].length < ctx2[1].length;
      if (dirty & 1537) {
        previewlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      previewlist.$set(previewlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
}
function create_item_key_slot$2(ctx) {
  let span;
  let t_value = ctx[8] + "";
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = ctx[8] === STORE_VALUE ? "internal" : "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 256 && t_value !== (t_value = ctx2[8] + ""))
        set_data(t, t_value);
      if (dirty & 256 && span_class_value !== (span_class_value = ctx2[8] === STORE_VALUE ? "internal" : "property")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot$2(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[6](ctx[8])
    }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 256)
        jsonnode_changes.value = ctx2[6](ctx2[8]);
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[5],
      $$slots: {
        item_value: [
          create_item_value_slot$2,
          ({ key }) => ({ 8: key }),
          ({ key }) => key ? 256 : 0
        ],
        item_key: [
          create_item_key_slot$2,
          ({ key }) => ({ 8: key }),
          ({ key }) => key ? 256 : 0
        ],
        preview: [create_preview_slot$2],
        summary: [create_summary_slot$2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 32)
        jsonnested_changes.keys = ctx2[5];
      if (dirty & 1311) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
const STORE_VALUE = "$value";
function instance$4($$self, $$props, $$invalidate) {
  let objectKeys;
  let keys;
  let previewKeys;
  let storeValue;
  let isWritableStore;
  let $value, $$unsubscribe_value = noop, $$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, ($$value) => $$invalidate(7, $value = $$value)), value);
  $$self.$$.on_destroy.push(() => $$unsubscribe_value());
  let { value } = $$props;
  $$subscribe_value();
  function getValue(key) {
    if (key === STORE_VALUE)
      return storeValue;
    return value[key];
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$subscribe_value($$invalidate(0, value = $$props2.value));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, objectKeys = Object.getOwnPropertyNames(value));
    }
    if ($$self.$$.dirty & 2) {
      $$invalidate(5, keys = [STORE_VALUE, ...objectKeys]);
    }
    if ($$self.$$.dirty & 2) {
      $$invalidate(4, previewKeys = objectKeys.slice(0, 5));
    }
    if ($$self.$$.dirty & 128) {
      $$invalidate(2, storeValue = $value);
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(3, isWritableStore = typeof value.set === "function");
    }
  };
  return [
    value,
    objectKeys,
    storeValue,
    isWritableStore,
    previewKeys,
    keys,
    getValue,
    $value
  ];
}
class JSONSvelteStoreNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$1(ctx) {
  let span;
  let t0;
  let t1;
  let t2_value = ctx[0].length + "";
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(ctx[1]);
      t1 = text("(");
      t2 = text(t2_value);
      t3 = text(")");
      attr(span, "class", "label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].length + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_slot(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({ props: { value: ctx[7] } });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 128)
        jsonnode_changes.value = ctx2[7];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_preview_slot$1(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: ctx[2],
      hasMore: ctx[2].length < ctx[0].length,
      label: ctx[1] + "(" + ctx[0].length + ") ",
      prefix: "[",
      postfix: "]",
      $$slots: {
        item: [
          create_item_slot,
          ({ item }) => ({ 7: item }),
          ({ item }) => item ? 128 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(previewlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const previewlist_changes = {};
      if (dirty & 4)
        previewlist_changes.list = ctx2[2];
      if (dirty & 5)
        previewlist_changes.hasMore = ctx2[2].length < ctx2[0].length;
      if (dirty & 3)
        previewlist_changes.label = ctx2[1] + "(" + ctx2[0].length + ") ";
      if (dirty & 384) {
        previewlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      previewlist.$set(previewlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
}
function create_item_key_slot$1(ctx) {
  let span;
  let t_value = String(ctx[6]) + "";
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = ctx[4].includes(ctx[6]) ? "internal" : "property");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = String(ctx2[6]) + ""))
        set_data(t, t_value);
      if (dirty & 64 && span_class_value !== (span_class_value = ctx2[4].includes(ctx2[6]) ? "internal" : "property")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot$1(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[5](ctx[6])
    }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 64)
        jsonnode_changes.value = ctx2[5](ctx2[6]);
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[3],
      $$slots: {
        item_value: [
          create_item_value_slot$1,
          ({ key }) => ({ 6: key }),
          ({ key }) => key ? 64 : 0
        ],
        item_key: [
          create_item_key_slot$1,
          ({ key }) => ({ 6: key }),
          ({ key }) => key ? 64 : 0
        ],
        preview: [create_preview_slot$1],
        summary: [create_summary_slot$1]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 8)
        jsonnested_changes.keys = ctx2[3];
      if (dirty & 327) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
const TO_STRING_TAG = "Symbol(Symbol.toStringTag)";
function instance$3($$self, $$props, $$invalidate) {
  let keys;
  let preview;
  let { value } = $$props;
  let { nodeType } = $$props;
  const internalKeys = ["buffer", "byteLength", "byteOffset", "length", TO_STRING_TAG];
  function getValue(key) {
    if (key === TO_STRING_TAG) {
      return value[Symbol.toStringTag];
    }
    return value[key];
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("nodeType" in $$props2)
      $$invalidate(1, nodeType = $$props2.nodeType);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(3, keys = [...Object.getOwnPropertyNames(value), ...internalKeys]);
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(2, preview = value.slice(0, 5));
    }
  };
  return [value, nodeType, preview, keys, internalKeys, getValue];
}
class TypedArrayNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { value: 0, nodeType: 1 });
  }
}
function add_css$1(target) {
  append_styles(target, "svelte-17k1wqt", ".regex.svelte-17k1wqt{color:var(--regex-color)}");
}
function create_summary_slot(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "regex svelte-17k1wqt");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_preview_slot(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "regex svelte-17k1wqt");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_key_slot(ctx) {
  let span;
  let t_value = String(ctx[3]) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "internal");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = String(ctx2[3]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_value_slot(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: { value: ctx[0][ctx[3]] }
  });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 9)
        jsonnode_changes.value = ctx2[0][ctx2[3]];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ctx[2],
      $$slots: {
        item_value: [
          create_item_value_slot,
          ({ key }) => ({ 3: key }),
          ({ key }) => key ? 8 : 0
        ],
        item_key: [
          create_item_key_slot,
          ({ key }) => ({ 3: key }),
          ({ key }) => key ? 8 : 0
        ],
        preview: [create_preview_slot],
        summary: [create_summary_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(jsonnested.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsonnested_changes = {};
      if (dirty & 27) {
        jsonnested_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let str;
  let { value } = $$props;
  const keys = [
    "lastIndex",
    "dotAll",
    "flags",
    "global",
    "hasIndices",
    "ignoreCase",
    "multiline",
    "source",
    "sticky",
    "unicode"
  ];
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, str = value.toString());
    }
  };
  return [value, str, keys];
}
class RegExpNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, { value: 0 }, add_css$1);
  }
}
function create_fragment$1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [{ value: ctx[0] }, ctx[1]];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 3 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 1 && { value: ctx2[0] },
        dirty & 2 && get_spread_object(ctx2[1])
      ]) : {};
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let componentType;
  let props;
  let $nodeType;
  let { value } = $$props;
  const nodeType = writable();
  component_subscribe($$self, nodeType, (value2) => $$invalidate(4, $nodeType = value2));
  function getComponentAndProps(nodeType2, value2) {
    switch (nodeType2) {
      case "Object":
        if (typeof value2.subscribe === "function")
          return [JSONSvelteStoreNode];
        return [JSONObjectNode];
      case "Error":
        return [ErrorNode];
      case "Array":
        return [JSONArrayNode];
      case "Map":
        return [JSONIterableMapNode];
      case "Iterable":
      case "Set":
        return [JSONIterableArrayNode, { nodeType: nodeType2 }];
      case "Number":
        return [JSONValueNode, { nodeType: nodeType2 }];
      case "String":
        return [JSONStringNode];
      case "Boolean":
        return [
          JSONValueNode,
          {
            nodeType: nodeType2,
            value: value2 ? "true" : "false"
          }
        ];
      case "Date":
        return [JSONValueNode, { nodeType: nodeType2, value: value2.toISOString() }];
      case "Null":
        return [JSONValueNode, { nodeType: nodeType2, value: "null" }];
      case "Undefined":
        return [JSONValueNode, { nodeType: nodeType2, value: "undefined" }];
      case "Function":
      case "AsyncFunction":
      case "AsyncGeneratorFunction":
      case "GeneratorFunction":
        return [JSONFunctionNode];
      case "Symbol":
        return [JSONValueNode, { nodeType: nodeType2, value: value2.toString() }];
      case "BigInt":
        return [JSONValueNode, { nodeType: nodeType2, value: String(value2) + "n" }];
      case "ArrayBuffer":
        return [
          JSONValueNode,
          {
            nodeType: nodeType2,
            value: `ArrayBuffer(${value2.byteLength})`
          }
        ];
      case "BigInt64Array":
      case "BigUint64Array":
      case "Float32Array":
      case "Float64Array":
      case "Int8Array":
      case "Int16Array":
      case "Int32Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Uint16Array":
      case "Uint32Array":
        return [TypedArrayNode, { nodeType: nodeType2 }];
      case "RegExp":
        return [RegExpNode];
      default:
        return [JSONValueNode, { nodeType: nodeType2, value: `<${nodeType2}>` }];
    }
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      set_store_value(nodeType, $nodeType = objType(value), $nodeType);
    }
    if ($$self.$$.dirty & 17) {
      $$invalidate(2, [componentType, props] = getComponentAndProps($nodeType, value), componentType, ($$invalidate(1, props), $$invalidate(4, $nodeType), $$invalidate(0, value)));
    }
  };
  return [value, props, componentType, nodeType, $nodeType];
}
class JSONNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { value: 0 });
  }
}
function getShouldExpandNode({ defaultExpandedPaths, defaultExpandedLevel }) {
  const defaultExpandedPathsParts = defaultExpandedPaths.map((path) => path.split("."));
  function matchPath(keyPath) {
    outer:
      for (const parts of defaultExpandedPathsParts) {
        if (keyPath.length > parts.length)
          continue;
        const length = Math.min(keyPath.length, parts.length);
        for (let i = 0; i < length; i++) {
          if (parts[i] !== "*" && parts[i] !== String(keyPath[i]))
            continue outer;
        }
        return true;
      }
    return false;
  }
  return function({ keyPath, level }) {
    return level <= defaultExpandedLevel || matchPath(keyPath);
  };
}
function add_css(target) {
  append_styles(target, "svelte-16cw61f", "ul.svelte-16cw61f{--string-color:var(--json-tree-string-color, #cb3f41);--symbol-color:var(--json-tree-symbol-color, #cb3f41);--boolean-color:var(--json-tree-boolean-color, #112aa7);--function-color:var(--json-tree-function-color, #112aa7);--number-color:var(--json-tree-number-color, #3029cf);--label-color:var(--json-tree-label-color, #871d8f);--property-color:var(--json-tree-property-color, #000000);--arrow-color:var(--json-tree-arrow-color, #727272);--operator-color:var(--json-tree-operator-color, #727272);--null-color:var(--json-tree-null-color, #8d8d8d);--undefined-color:var(--json-tree-undefined-color, #8d8d8d);--date-color:var(--json-tree-date-color, #8d8d8d);--internal-color:var(--json-tree-internal-color, grey);--regex-color:var(--json-tree-regex-color, var(--string-color));--li-identation:var(--json-tree-li-indentation, 1em);--li-line-height:var(--json-tree-li-line-height, 1.3);font-size:var(--json-tree-font-size, 12px);font-family:var(--json-tree-font-family, 'Courier New', Courier, monospace)}ul.svelte-16cw61f li{line-height:var(--li-line-height);display:var(--li-display, list-item);list-style:none}ul.svelte-16cw61f,ul.svelte-16cw61f ul{padding:0;margin:0}ul.svelte-16cw61f{margin-left:var(--li-identation)}ul.svelte-16cw61f{cursor:default}ul.svelte-16cw61f .label{color:var(--label-color)}ul.svelte-16cw61f .property{color:var(--property-color)}ul.svelte-16cw61f .internal{color:var(--internal-color)}ul.svelte-16cw61f .operator{color:var(--operator-color)}");
}
function create_default_slot(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({ props: { value: ctx[0] } });
  return {
    c() {
      create_component(jsonnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty & 1)
        jsonnode_changes.value = ctx2[0];
      jsonnode.$set(jsonnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
}
function create_fragment(ctx) {
  let ul;
  let expandable;
  let current;
  expandable = new Expandable({
    props: {
      key: "$",
      expanded: ctx[1],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      ul = element("ul");
      create_component(expandable.$$.fragment);
      attr(ul, "class", "svelte-16cw61f");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      mount_component(expandable, ul, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expandable_changes = {};
      if (dirty & 33) {
        expandable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandable.$set(expandable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expandable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_component(expandable);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let shouldExpandNode;
  let { value } = $$props;
  let { defaultExpandedPaths = [] } = $$props;
  let { defaultExpandedLevel = 0 } = $$props;
  const expanded = writable(true);
  useState({
    expanded,
    isParentExpanded: readable(true),
    root: true,
    shouldExpandNode: (opts) => shouldExpandNode(opts),
    level: 0,
    keyPath: []
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("defaultExpandedPaths" in $$props2)
      $$invalidate(2, defaultExpandedPaths = $$props2.defaultExpandedPaths);
    if ("defaultExpandedLevel" in $$props2)
      $$invalidate(3, defaultExpandedLevel = $$props2.defaultExpandedLevel);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      shouldExpandNode = getShouldExpandNode({
        defaultExpandedPaths,
        defaultExpandedLevel
      });
    }
  };
  return [value, expanded, defaultExpandedPaths, defaultExpandedLevel];
}
class Root extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      value: 0,
      defaultExpandedPaths: 2,
      defaultExpandedLevel: 3
    }, add_css);
  }
}
export { Root as default };
